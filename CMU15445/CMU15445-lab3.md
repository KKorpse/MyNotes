@[TOC](文章目录)

---

![在这里插入图片描述](https://img-blog.csdnimg.cn/38b8af72caa4497c89289e770ce190b7.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/db9cf6e658a3472dadc975dc66f44dbd.png)



感觉Project3像一个读代码任务，不琢磨懂bustub的代码完全没法动笔。

文档只讲了需要实现的笼统需求，大部分跟下手代码相关的信息全在代码里面，需要从测试文件，Executor的构造函数等地方延申读各种头文件，理解了之后才能拿来使用且完成任务。

#### TASK #0 - BEFOR START

##### 0-Question

1. You must modify the `ExecutionEngine` to catch any exception that your executors throw as a result of failures during query execution.哪些异常需要被抓住？抓了有啥用在哪儿用
2. 妈的table的信息在那儿找啊



##### AbstractExecutor

SQL拆分成一棵执行树之后，其中的节点的功能承担者，也是这次实验主要要完成的部分。

```cpp
// 还不知道要初始化一些啥东西
void Init()
    
// 官方文档有介绍
void Next(Tuple *tuple, RID *rid)
    
// Schema相当于存储了表的表头名字，OutputSchema用来指出此节点需要输出哪些列（哪些表头需要考虑在内）
virtual const Schema *GetOutputSchema() = 0;
```



##### ExecutorContext（AbstractExecutor构造函数的参数之一）

上下文信息，也就是说这次执行所用到的一些关键信息

```c++
Transaction *transaction_;

// 这个Catalog至关重要，存储了一个数据库的全部表格信息的索引，提供了对表格的操作。
Catalog *catalog_;

BufferPoolManager *bpm_;

TransactionManager *txn_mgr_;

LockManager *lock_mgr_;
```



##### AbstractPlanNode（AbstractExecutor构造函数参数之二）

用于存储节点有关的信息，`AbstractExecutor`利用用里面的信息来完成任务。

```cpp
// Schema是表每列的表头名字，OutputSchema用来指出此节点需要输出哪些列
const Schema *OutputSchema() const

// 获取孩子节点
const AbstractPlanNode *GetChildAt(uint32_t child_idx)
const std::vector<const AbstractPlanNode *> &GetChildren()
```

例子：`SeqScanPlanNode`成员函数，`AbstractExecutor`可以在这里获取`TableOid`和`Predicate`

```c++
// 这个在ExecutionEngine里面用于判断当前节点的类型
PlanType GetType()

const AbstractExpression *GetPredicate() 
    
// 结合Catlog可以得到当前Executor需要的表格内容
table_oid_t GetTableOid() 
```



##### Catalog

存储了一个数据库的全部表格信息的索引，提供了对表格的操作。

```c++
// TableInfo装载某个table的相关信息，包括schema，name，table指针，oid
TableInfo *GetTable(table_oid_t table_oid)

// IndexInfo 同理
IndexInfo *GetIndex(table_oid_t table_oid) 
    
IndexInfo *CreateIndex(...)
    
IndexInfo *GetIndex(index_oid_t index_oid)

std::vector<IndexInfo *> GetTableIndexes(const std::string &table_name)
   
```



##### Value：最小数据单位



##### Table三剑客（数据存储）![image-20220703104344569](C:\Users\54351\Desktop\MyNotes\CMU15445\CMU15445-lab3.assets\image-20220703104344569.png)

**tuple**：相当于表里面的一行，存储了一行`value`。长度由`shema`决定，每个`column`可以在`tuple`中对应一个`value`

```c++
// serialize tuple data（就是将数据二进制化，用于存储）
void SerializeTo(char *storage) const;
void DeserializeFrom(const char *storage);

// return RID of current tuple
inline RID GetRid()

// 返回数据指针
inline char *GetData()

// 返回tuple的长度（bits）
inline uint32_t GetLength()

// 返回指定colum_idx位置的值
Value GetValue(const Schema *schema, uint32_t column_idx)

// Generates a key tuple given schemas and attributes
Tuple KeyFromTuple(const Schema &schema, const Schema &key_schema, const std::vector<uint32_t> &key_attrs);

// Is the column value null ?
inline bool IsNull(const Schema *schema, uint32_t column_idx) 

inline bool IsAllocated() { return allocated_; }

std::string ToString(const Schema *schema) const;

```





##### Catalog三剑客（数据表信息）![image-20220710201126112](C:\Users\54351\Desktop\Mynotes\CMU15445\CMU15445-lab3.assets\image-20220710201126112.png)

###### **schema**

```cpp
// 返回单个tuple的长度（不是schema的长度哦）
inline uint32_t GetLength()

// 返回是否内联
inline bool IsInlined() const { return tuple_is_inlined_; }
```



#### TASK #1 - EXECUTORS

##### SEQUENTIAL SCAN

##### INSERT

##### UPDATE

##### DELETE

##### NESTED LOOP JOIN

##### HASH JOIN

##### AGGREGATION

##### LIMIT

##### DISTINCT